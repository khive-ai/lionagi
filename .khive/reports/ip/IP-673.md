---
title: Lionagi Refactoring Implementation Plan (Issue #673)
by: khive-implementer
created: 2025-05-19
updated: 2025-05-19
version: 1.0
doc_type: IP
output_subdir: ip
description: Implementation Plan for the refactoring of the lionagi package (Issue #673).
date: 2025-05-19
author: "@khive-implementer"
status: Draft
related_issue: 673
research_report: RR-673.md
technical_design: TDS-673.md
---

# Implementation Plan: `lionagi` Package Refactoring

## 1. Overview

This document outlines the implementation plan for refactoring the `lionagi` Python package as specified in the Technical Design Specification (TDS-673). The refactoring aims to transform `lionagi` into a high-level abstraction layer by leveraging the specialized capabilities of the `lionfuncs` and `pydapter` libraries.

## 2. Implementation Approach

The implementation will follow Test-Driven Development (TDD) principles:
1. Write failing tests for the new functionality
2. Implement the functionality to make the tests pass
3. Refactor the code while maintaining passing tests

The refactoring will be implemented in stages to ensure that each component is properly tested and integrated.

## 3. Implementation Stages

### Stage 1: Project Setup and Initial Structure (1 day)

1. **Create the new directory structure**
   - Set up the new directory structure as outlined in TDS-673, Section 5.6
   - Create placeholder files for the new modules

2. **Update dependencies in `pyproject.toml`**
   - Add `lionfuncs` and `pydapter` as dependencies
   - Update Python version requirement to >= 3.9

3. **Create test infrastructure**
   - Set up test directories mirroring the new structure
   - Create test fixtures and helpers

### Stage 2: Core Models Implementation (2 days)

1. **Implement base models with `pydapter.Adaptable`**
   - Create `lionagi/models/base.py` with base model classes
   - Implement `Message`, `Branch`, and `Session` models as defined in TDS-673, Section 4.1
   - Write comprehensive tests for these models

2. **Implement model serialization/deserialization**
   - Integrate `pydapter` for model adaptation
   - Test conversion to/from various formats

### Stage 3: Core Components Implementation (3 days)

1. **Implement `lionagi.core.orchestrator`**
   - Develop the conversation flow management logic
   - Implement tool call handling
   - Write tests for orchestrator functionality

2. **Implement `lionagi.core.state_manager`**
   - Develop session/branch state management
   - Integrate with `pydapter` for serialization
   - Test state persistence and retrieval

3. **Implement `lionagi.core.service_interface`**
   - Create the interface to `lionfuncs.network.adapters`
   - Implement request/response mapping
   - Test LLM service interactions

4. **Implement `lionagi.core.tool_manager`**
   - Develop tool registration and execution logic
   - Implement schema generation using `lionfuncs.schema_utils`
   - Test tool execution flow

### Stage 4: Public API Implementation (2 days)

1. **Implement `lionagi.__init__.py`**
   - Define the public API exports
   - Create simplified interfaces for end users
   - Test the public API

2. **Implement `lionagi.settings.py`**
   - Update settings for the refactored package
   - Implement configuration handling
   - Test configuration loading and application

### Stage 5: Built-in Tools Implementation (1 day)

1. **Implement any built-in high-level tools**
   - Create `lionagi/tools/` directory with basic tools
   - Test tool functionality

### Stage 6: Integration Testing and Documentation (2 days)

1. **Perform integration testing**
   - Test end-to-end workflows
   - Verify compatibility with `lionfuncs` and `pydapter`

2. **Update documentation**
   - Update docstrings and type hints
   - Create examples for common use cases

### Stage 7: Final Cleanup and Preparation for PR (1 day)

1. **Run linters and formatters**
   - Ensure code meets style guidelines
   - Fix any issues identified

2. **Verify test coverage**
   - Ensure >80% test coverage
   - Add tests for any uncovered code paths

3. **Prepare PR**
   - Create detailed PR description
   - Link to Issue #673

## 4. Testing Strategy

### 4.1 Unit Testing

- **Models**: Test validation, serialization/deserialization, and `pydapter` integration
- **Core Components**: Test individual components with mocked dependencies
- **Public API**: Test the public interfaces with various inputs

### 4.2 Integration Testing

- **End-to-End Workflows**: Test complete workflows like chat with tool use
- **Library Integration**: Test integration with `lionfuncs` and `pydapter`
- **Error Handling**: Test error propagation and handling

### 4.3 Test Coverage

- Aim for >80% test coverage overall
- Focus on critical paths and error handling
- Use pytest fixtures for common test scenarios

## 5. Implementation Details

### 5.1 Directory Structure

```
lionagi/
├── __init__.py
├── version.py
├── settings.py
│
├── core/
│   ├── __init__.py
│   ├── orchestrator.py
│   ├── state_manager.py
│   ├── service_interface.py
│   ├── tool_manager.py
│   └── utils.py
│
├── models/
│   ├── __init__.py
│   ├── base.py
│   ├── message.py
│   ├── session.py
│   └── ...
│
├── tools/
│   ├── __init__.py
│   └── web_search_tool.py
│
└── py.typed
```

### 5.2 Key Implementation Considerations

1. **`lionfuncs` Integration**:
   - Use `lionfuncs.utils` for general utilities
   - Use `lionfuncs.errors` for error handling
   - Use `lionfuncs.file_system` for file operations
   - Use `lionfuncs.async_utils` and `lionfuncs.concurrency` for async operations
   - Use `lionfuncs.network.adapters` for LLM service interactions

2. **`pydapter` Integration**:
   - Use `pydapter.Adaptable` mixin for all models
   - Register appropriate adapters for serialization/deserialization
   - Leverage async capabilities for async operations

3. **Removal of Deprecated Components**:
   - Remove `lionagi/adapters/` (replaced by `pydapter`)
   - Remove `lionagi/libs/` (functionality moved to `lionfuncs` or obsolete)
   - Remove `lionagi/_errors.py` (replaced by `lionfuncs.errors`)
   - Remove `lionagi/service/providers/` (replaced by `lionfuncs.network.adapters`)
   - Remove `lionagi/service/endpoints/` (relocated to "khive")
   - Remove `lionagi/protocols/` (functionality absorbed into `lionagi.core` and `lionagi.models`)
   - Remove `lionagi/_class_registry.py` (likely removed or significantly simplified)

## 6. Dependencies

- Python >= 3.9
- `lionfuncs` (for utilities, async operations, file I/O, network interactions, error handling)
- `pydapter` (for data adaptation)
- `pydantic` (for data modeling and validation)

## 7. Risks and Mitigations

1. **Risk**: Gaps in `lionfuncs` or `pydapter` functionality compared to existing `lionagi` components.
   **Mitigation**: Identify gaps early and implement temporary solutions in `lionagi.core.utils` with TODOs for future refactoring.

2. **Risk**: Complexity in integrating the new `Tool` mechanism.
   **Mitigation**: Start with simple tool examples and gradually add complexity, with thorough testing at each step.

3. **Risk**: Backward compatibility issues.
   **Mitigation**: Focus on a well-reasoned new API rather than maintaining backward compatibility, as specified in the TDS.

4. **Risk**: Performance bottlenecks.
   **Mitigation**: Monitor performance during implementation and address any issues early.

## 8. Timeline

Total estimated time: 12 working days

- Stage 1: Project Setup and Initial Structure (1 day)
- Stage 2: Core Models Implementation (2 days)
- Stage 3: Core Components Implementation (3 days)
- Stage 4: Public API Implementation (2 days)
- Stage 5: Built-in Tools Implementation (1 day)
- Stage 6: Integration Testing and Documentation (2 days)
- Stage 7: Final Cleanup and Preparation for PR (1 day)

## 9. Conclusion

This implementation plan provides a structured approach to refactoring the `lionagi` package according to the specifications in TDS-673. By following this plan and adhering to TDD principles, we will create a more modular, maintainable, and powerful `lionagi` library that leverages the specialized capabilities of `lionfuncs` and `pydapter`.

---
title: Lionagi Refactoring Research (Issue #673)
by: khive-researcher
created: 2025-04-12
updated: 2025-05-19
version: 1.9
doc_type: RR
output_subdir: rr
description: Research report on lionfuncs and pydapter for lionagi refactoring (Issue #673).
date: 2025-05-19
author: "@khive-researcher"
status: Complete
---

# Guidance

**Purpose**\
To document your in-depth research findings about new technologies, architecture
approaches, or library evaluations. Provides evidence-based recommendations for
the Architect to rely on.

**When to Use**

- Whenever the Orchestrator requests a deep dive on a specific domain or
  problem.
- Before or during the design phase.

**Best Practices**

- Include comparisons (tables of pros/cons, cost, performance).
- Cite sources.
- Focus on actionable insights relevant to khive’s constraints.

---

# Research Report: lionagi Refactoring (Issue #673) - lionfuncs & pydapter Analysis

## Executive Summary

This research analyzed the `lionfuncs` and `pydapter` libraries to support the refactoring of the `lionagi` package (Issue #673). The primary goal was to identify functionalities within these libraries that can replace or simplify existing components in `lionagi`.

Comprehensive documentation for `lionfuncs` (owner: `khive-ai`, repo: `lionfuncs`) was provided directly by the user, and its repository `README.md` was also fetched via MCP. `lionfuncs` offers a rich set of utilities for asynchronous operations, file systems, network interactions (including SDK adapters for OpenAI and Anthropic), concurrency management, error handling, and various data manipulation tasks. A detailed analysis indicates that numerous functions and patterns in `lionagi` (within `utils.py`, `libs/`, `_errors.py`, and custom async/concurrency logic) have direct or superior counterparts in `lionfuncs`. Adopting `lionfuncs` is expected to significantly simplify, standardize, and enhance `lionagi`.

For `pydapter` (owner: `khive-ai`, repo: `pydapter`), its `README.md` was fetched via MCP. It describes `pydapter` as a type-safe adapter toolkit for Pydantic models, supporting two-way conversion, an `Adaptable` mixin, async operations, and various formats (JSON, CSV, TOML, pandas, Excel) and database integrations. `pydapter` is a strong candidate to fully replace and enhance `lionagi/adapters/`.

The main recommendation is to proceed with a detailed mapping and replacement strategy for `lionagi` components using `lionfuncs` for core utilities and `pydapter` for data adaptation. This includes refactoring `lionagi.service.providers` to use `lionfuncs.network.adapters`.

## 1. Introduction

### 1.1 Research Objective

This research aims to analyze the `lionfuncs` and `pydapter` libraries to determine how they can be leveraged to refactor the `lionagi` package, as per GitHub Issue #673. The primary goal is to identify functionalities within `lionfuncs` that can replace similar functions in `lionagi`, and to understand how `pydapter` can replace `lionagi/adapters/`. This includes utilities, protocols (in terms of underlying implementation support), concurrency mechanisms, and adapter functionalities.

### 1.2 Methodology

1.  **Initial Local Path Check:** Exploration of local paths ([`./.khive/resources/lionfuncs_docs/`](./.khive/resources/lionfuncs_docs/), [`./.khive/resources/pydapter_docs/`](./.khive/resources/pydapter_docs/)) found no documentation files.
2.  **`lionfuncs` Documentation:**
    *   Comprehensive documentation provided directly by the user (Cited as "User-provided `lionfuncs` documentation, 2025-05-19").
    *   `README.md` fetched from `khive-ai/lionfuncs` via MCP (Cited as `(mcp:github:khive-ai/lionfuncs/README.md)`).
3.  **`pydapter` Information Discovery:**
    *   `README.md` fetched from `khive-ai/pydapter` via MCP (Cited as `(mcp:github:khive-ai/pydapter/README.md)`).
4.  **Analysis:** Review of all gathered documentation to map features to `lionagi` components.

### 1.3 Context

The `lionagi` package is undergoing a significant refactoring to become a higher-level abstraction layer, delegating specialized functionalities to `lionfuncs` and `pydapter`.

### 1.4 Scope Adjustment

Analysis of the "khive" library and "endpoint/reader" relocation is out of scope for this report.

## 2. Technical Analysis

### 2.1 Analysis of `lionfuncs`

**2.1.1 Documentation Source**

Primary analysis is based on comprehensive documentation provided directly by the user (User-provided `lionfuncs` documentation, 2025-05-19). The `README.md` from the `khive-ai/lionfuncs` repository (mcp:github:khive-ai/lionfuncs/README.md) was also fetched and found to be consistent, providing a high-level overview (see Appendix D).

**2.1.2 Key `lionfuncs` Modules and Potential `lionagi` Replacements**

(Detailed mapping based on "User-provided `lionfuncs` documentation, 2025-05-19")

*   **`lionfuncs.utils`**: Offers `is_coro_func`, `force_async`, `get_env_bool`, `get_env_dict`, `to_list`, `to_dict`. These can replace numerous custom utilities in [`lionagi/utils.py`](./lionagi/utils.py) and [`lionagi/libs/parse/to_dict.py`](./lionagi/libs/parse/to_dict.py).
*   **`lionfuncs.errors`**: Provides a structured error hierarchy (e.g., `LionError`, `LionFileError`, `LionNetworkError`). Recommended to replace [`lionagi/_errors.py`](./lionagi/_errors.py) for standardized error handling.
*   **`lionfuncs.file_system`**: Includes `read_file`, `save_to_file`, `list_files`, `chunk_content`, etc., capable of replacing most of [`lionagi/libs/file/`](./lionagi/libs/file/).
*   **`lionfuncs.concurrency` & `lionfuncs.async_utils`**: Offer `BoundedQueue`, `WorkQueue`, `alcall`, `bcall`, `@max_concurrent`, `@throttle`, `CancelScope`, `TaskGroup`. These provide robust replacements for custom async/concurrency patterns in `lionagi`, including direct replacements for [`lionagi.utils.alcall`](./lionagi/utils.py) and [`bcall`](./lionagi/utils.py).
*   **`lionfuncs.network`**: Features `AsyncAPIClient`, resilience decorators (`@circuit_breaker`, `@with_retry`), and notably, SDK adapters (`OpenAIAdapter`, `AnthropicAdapter`). These SDK adapters are strong candidates to replace the provider-specific logic in `lionagi.service.providers/`.
*   **Specialized Utilities**:
    *   `lionfuncs.text_utils.string_similarity` can replace [`lionagi/libs/validate/string_similarity.py`](./lionagi/libs/validate/string_similarity.py).
    *   `lionfuncs.parsers.fuzzy_parse_json` can replace [`lionagi/libs/parse/fuzzy_parse_json.py`](./lionagi/libs/parse/fuzzy_parse_json.py).
    *   `lionfuncs.dict_utils.fuzzy_match_keys` can replace [`lionagi/libs/validate/fuzzy_match_keys.py`](./lionagi/libs/validate/fuzzy_match_keys.py).
    *   `lionfuncs.format_utils.as_readable` can replace [`lionagi/libs/schema/as_readable.py`](./lionagi/libs/schema/as_readable.py).
    *   `lionfuncs.schema_utils.function_to_openai_schema` can replace [`lionagi/libs/schema/function_to_schema.py`](./lionagi/libs/schema/function_to_schema.py).

**Implications for `lionagi.protocols/`**: `lionfuncs` utilities will serve as robust building blocks for implementing `lionagi`'s application-level protocols.

### 2.2 Analysis of `pydapter`

**2.2.1 Documentation Source & Key Findings** (mcp:github:khive-ai/pydapter/README.md)

`pydapter`'s `README.md` (see Appendix C) describes it as a type-safe adapter toolkit for Pydantic models.
*   **Core Features:** Two-way conversion, `Adaptable` Mixin for models, async support, multiple format adapters (JSON, CSV, TOML, pandas, Excel), and database adapters (Postgres, Mongo, Neo4j, Qdrant, SQL).
*   **Relevance to `lionagi/adapters/`:** `pydapter` is a strong candidate to fully replace and enhance [`lionagi/adapters/`](./lionagi/adapters/). It covers existing `lionagi` capabilities and adds many more. The `Adaptable` mixin is a key feature for integrating conversions directly into `lionagi`'s Pydantic models.
*   **Potential Simplification:** Expected to reduce boilerplate, standardize adaptation logic, and broaden format support in `lionagi`.

## 4. Integration Considerations

### 4.1 Redundancies and Integration Points

*   **`lionagi/utils.py`**, **`lionagi/_errors.py`**, **`lionagi/libs/*`**, **custom async/concurrency logic**: Largely replaceable by corresponding `lionfuncs` modules.
*   **`lionagi/adapters/`**: To be replaced by `pydapter`.
*   **`lionagi/service/providers/`**: Provider-specific SDK interaction logic can likely be replaced by `lionfuncs.network.adapters`.

### 4.2 "Endpoint" and "Reader" Relocation Considerations

Out of scope for this report.

## 5. Recommendations

1.  **Full Adoption of `lionfuncs`:** Proceed with a detailed plan to refactor `lionagi` to use `lionfuncs` for core utilities, error handling, file operations, async/concurrency management, network interactions (including SDKs via `lionfuncs.network.adapters`), and specialized parsing/formatting/schema tasks as identified.
2.  **Integrate `pydapter`:** Replace [`lionagi/adapters/`](./lionagi/adapters/) entirely with `pydapter`, leveraging its `Adaptable` mixin for `lionagi`'s Pydantic models.
3.  **Architectural Review:** The @khive-architect should review these findings to guide the detailed design of the refactored `lionagi`, particularly the interaction between `lionagi.service`, `lionfuncs.network.adapters`, and `pydapter`.

## 6. References
1. GitHub Issue #673
2. `lionagi` Repository
3. Task Definition for @khive-researcher
4. Exa Search ID for `lionfuncs` query: `71dfda1b118d767b3d4074ba163b6875` (see Appendix A).
5. Repository information provided by user: `pydapter` (`khive-ai/pydapter`), `lionfuncs` (`khive-ai/lionfuncs`).
6. User-provided `lionfuncs` documentation (2025-05-19).
7. `pydapter` `README.md` (mcp:github:khive-ai/pydapter/README.md).
8. `lionfuncs` `README.md` (mcp:github:khive-ai/lionfuncs/README.md).

## Appendices

### Appendix A: Search Logs

**Exa Search for `lionfuncs` (Query: "lionfuncs library khive-ai github", ID: `71dfda1b118d767b3d4074ba163b6875`)**
```json
{
  "success": true,
  "action_performed": "search",
  "content": {
    "requestId": "71dfda1b118d767b3d4074ba163b6875",
    "resolvedSearchType": "neural",
    "results": [
      {
        "id": "https://github.com/lucidrains/lion-pytorch",
        "title": "GitHub - lucidrains/lion-pytorch: 🦁 Lion, new optimizer discovered by Google Brain using genetic algorithms that is purportedly better than Adam(w), in Pytorch",
        "url": "https://github.com/lucidrains/lion-pytorch",
        "publishedDate": "2023-02-15T04:24:19.000Z",
        "author": "lucidrains",
        "score": 0.23984785377979279
      },
      {
        "id": "https://github.com/google/automl/tree/master/lion",
        "title": "automl/lion at master · google/automl",
        "url": "https://github.com/google/automl/tree/master/lion",
        "publishedDate": "2020-03-12T03:52:47.000Z",
        "author": "",
        "score": 0.2556593418121338
      },
      {
        "id": "https://github.com/TimDettmers/bitsandbytes/blob/main/bitsandbytes/optim/lion.py",
        "title": "bitsandbytes/bitsandbytes/optim/lion.py at main · TimDettmers/bitsandbytes",
        "url": "https://github.com/TimDettmers/bitsandbytes/blob/main/bitsandbytes/optim/lion.py",
        "publishedDate": "2021-06-04T00:10:34.000Z",
        "author": "TimDettmers",
        "score": 0.25274720788002014
      },
      {
        "id": "https://github.com/Rocketknight1/lion-tf",
        "title": "GitHub - Rocketknight1/lion-tf: A TensorFlow implementation of the Lion optimizer",
        "url": "https://github.com/Rocketknight1/lion-tf",
        "publishedDate": "2023-02-16T15:39:24.000Z",
        "author": "Rocketknight1",
        "score": 0.2545435130596161
      },
      {
        "id": "https://github.com/OrigamiDream/lion-tf",
        "title": "GitHub - OrigamiDream/lion-tf: Lion - EvoLved Sign Momentum w/ New Optimizer API in TensorFlow 2.11+",
        "url": "https://github.com/OrigamiDream/lion-tf",
        "publishedDate": "2023-02-16T14:57:53.000Z",
        "author": "OrigamiDream",
        "score": 0.24715951085090637
      },
      {
        "id": "https://github.com/GLambard/Lion-tensorflow",
        "title": "GitHub - GLambard/Lion-tensorflow: Implementation of the Lion optimizer in TensorFlow from https://arxiv.org/abs/2302.06675",
        "url": "https://github.com/GLambard/Lion-tensorflow",
        "publishedDate": "2023-02-17T01:07:57.000Z",
        "author": "GLambard",
        "score": 0.23751375079154968
      },
      {
        "id": "https://github.com/mingchikuo/tensorflow-lion-optimizer-with-warmup",
        "title": "GitHub - mingchikuo/tensorflow-lion-optimizer-with-warmup: Based on the Google Research Lion optimizer, incorporating my personal implementation of batch warm-up functionality.",
        "url": "https://github.com/mingchikuo/tensorflow-lion-optimizer-with-warmup",
        "publishedDate": "2023-10-05T13:12:09.000Z",
        "author": "mingchikuo",
        "score": 0.24310947954654694
      },
      {
        "id": "https://github.com/rasbt/try-lion-optimizer",
        "title": "GitHub - rasbt/try-lion-optimizer",
        "url": "https://github.com/rasbt/try-lion-optimizer",
        "publishedDate": "2023-03-09T20:31:09.000Z",
        "author": "rasbt",
        "score": 0.23845815658569336
      },
      {
        "id": "https://github.com/standardsemiconductor/lion/tree/f67b1fa119aaad1c9831f833748886d4e1e9469b/lion-formal",
        "title": "lion/lion-formal at f67b1fa119aaad1c9831f833748886d4e1e9469b · standardsemiconductor/lion",
        "url": "https://github.com/standardsemiconductor/lion/tree/f67b1fa119aaad1c9831f833748886d4e1e9469b/lion-formal",
        "publishedDate": "2021-02-18T03:18:12.000Z",
        "author": "standardsemiconductor",
        "score": 0.23807893693447113
      },
      {
        "id": "https://github.com/lion-agi",
        "title": "lion-agi",
        "url": "https://github.com/lion-agi",
        "publishedDate": "2024-12-24T18:26:38.000Z",
        "author": "",
        "score": 0.2682930529117584
      }
    ],
    "costDollars": {
      "total": 0.005,
      "search": {
        "neural": 0.005
      }
    }
  }
}
```

### Appendix B: `lionfuncs` Documentation (Provided by User)
(Summary: Comprehensive documentation covering core utilities, errors, file system, concurrency, async utilities, network client, resilience patterns, SDK adapters, text processing, parsers, dictionary utilities, formatting, and schema generation. This was the primary source for `lionfuncs` analysis.)

### Appendix C: `pydapter` README.md Content (Decoded)
```markdown
# Pydapter: Elegant Adapters for Pydantic Models

[![PyPI version](https://img.shields.io/pypi/v/pydapter.svg)](https://pypi.org/project/pydapter/)
[![PyPI - Downloads](https://img.shields.io/pypi/dm/pydapter?color=blue)](https://pypi.org/project/pydapter/)
[![Python Version](https://img.shields.io/badge/python-3.9%2B-blue)](https://www.python.org/downloads/release/python-390/)
[![License](https://img.shields.io/github/license/ohdearquant/pydapter.svg)](https://github.com/ohdearquant/pydapter/blob/main/LICENSE)

Pydapter is a lightweight, type-safe adapter toolkit for Pydantic that enables
seamless conversion between Pydantic models and various data formats and storage
systems.

## Features

- ✨ **Two-way Conversion**: Transform data between Pydantic models and external
  formats/sources
- 🧩 **Adaptable Mixin**: Add conversion capabilities directly to your models
- ⚡ **Async Support**: Full support for asynchronous operations
- 🔄 **Multiple Formats**: Support for JSON, CSV, TOML, pandas DataFrames,
  Excel, and more
- 💾 **Database Integration**: Connect to PostgreSQL, MongoDB, Neo4j, Qdrant,
  and others
- 🛡️ **Type-Safe**: Leverage Pydantic's validation for reliable data handling
- 🛠️ **Error Handling**: Comprehensive error types for different failure
  scenarios

## Installation

```bash
# Basic installation
pip install pydapter

# With database support
pip install "pydapter[postgres,mongo,neo4j,qdrant]"

# With pandas support
pip install "pydapter[pandas]"
```

## Quick Start

### Basic Adapter Usage

```python
from pydantic import BaseModel
from typing import List
from pydapter.adapters.json_ import JsonAdapter

# Define a Pydantic model
class User(BaseModel):
    id: int
    name: str
    email: str
    active: bool = True
    tags: List[str] = []

# Create a user
user = User(id=1, name="Alice", email="alice@example.com", tags=["admin"])

# Convert to JSON
json_data = JsonAdapter.to_obj(user)
print(json_data)

# Convert back to model
loaded_user = JsonAdapter.from_obj(User, json_data)
print(loaded_user)
```

### Using the Adaptable Mixin

```python
from pydantic import BaseModel
from pydapter.core import Adaptable
from pydapter.adapters.json_ import JsonAdapter
from pydapter.adapters.csv_ import CsvAdapter

# Define a model with the Adaptable mixin
class Product(BaseModel, Adaptable):
    id: int
    name: str
    price: float
    in_stock: bool = True

# Register adapters
Product.register_adapter(JsonAdapter)
Product.register_adapter(CsvAdapter)

# Create a product
product = Product(id=101, name="Laptop", price=999.99)

# Convert to different formats using the mixin methods
json_data = product.adapt_to(obj_key="json")
csv_data = product.adapt_to(obj_key="csv")

# Convert back to models
product_from_json = Product.adapt_from(json_data, obj_key="json")
```

## Available Adapters

Pydapter includes adapters for various data formats and storage systems:

### File Format Adapters

- `JsonAdapter`: JSON files and strings
- `CsvAdapter`: CSV files and strings
- `TomlAdapter`: TOML files and strings

### Data Analysis Adapters

- `DataFrameAdapter`: pandas DataFrame
- `SeriesAdapter`: pandas Series
- `ExcelAdapter`: Excel files (requires pandas and openpyxl/xlsxwriter)

### Database Adapters

- `PostgresAdapter` / `AsyncPostgresAdapter`: PostgreSQL
- `MongoAdapter` / `AsyncMongoAdapter`: MongoDB
- `Neo4jAdapter`: Neo4j graph database
- `QdrantAdapter` / `AsyncQdrantAdapter`: Qdrant vector database
- `SQLAdapter` / `AsyncSQLAdapter`: Generic SQL (SQLAlchemy)

## Detailed Examples

### Working with PostgreSQL

```python
from pydantic import BaseModel
from typing import Optional
from pydapter.extras.postgres_ import PostgresAdapter

class User(BaseModel):
    id: Optional[int] = None
    name: str
    email: str

# Read from database
users = PostgresAdapter.from_obj(
    User,
    {
        "engine_url": "postgresql+psycopg://user:pass@localhost/dbname",
        "table": "users",
        "selectors": {"active": True}
    },
    many=True
)

# Store in database
user = User(name="Alice", email="alice@example.com")
PostgresAdapter.to_obj(
    user,
    engine_url="postgresql+psycopg://user:pass@localhost/dbname",
    table="users"
)
```

### Working with MongoDB

```python
from pydantic import BaseModel
from typing import List
from pydapter.extras.mongo_ import MongoAdapter

class Product(BaseModel):
    id: str
    name: str
    price: float
    categories: List[str] = []

# Query from MongoDB
products = MongoAdapter.from_obj(
    Product,
    {
        "uri": "mongodb://localhost:27017",
        "db": "shop",
        "collection": "products",
        "filter": {"price": {"$lt": 100}}
    },
    many=True
)

# Store in MongoDB
product = Product(id="prod1", name="Headphones", price=49.99, categories=["audio", "accessories"])
MongoAdapter.to_obj(
    product,
    uri="mongodb://localhost:27017",
    db="shop",
    collection="products"
)
```

### Vector Search with Qdrant

```python
from pydantic import BaseModel
from typing import List
from sentence_transformers import SentenceTransformer
from pydapter.extras.qdrant_ import QdrantAdapter

# Load a model to generate embeddings
model = SentenceTransformer('all-MiniLM-L6-v2')

class Document(BaseModel):
    id: str
    title: str
    content: str
    embedding: List[float] = []

    def generate_embedding(self):
        self.embedding = model.encode(self.content).tolist()
        return self

# Create and store a document
doc = Document(
    id="doc1",
    title="Vector Databases",
    content="Vector databases store high-dimensional vectors for similarity search."
).generate_embedding()

QdrantAdapter.to_obj(
    doc,
    collection="documents",
    url="http://localhost:6333"
)

# Search for similar documents
query_vector = model.encode("How do vector databases work?").tolist()
results = QdrantAdapter.from_obj(
    Document,
    {
        "collection": "documents",
        "query_vector": query_vector,
        "top_k": 5,
        "url": "http://localhost:6333"
    },
    many=True
)
```

### Graph Database with Neo4j

```python
from pydantic import BaseModel
from typing import List
from pydapter.extras.neo4j_ import Neo4jAdapter

class Person(BaseModel):
    id: str
    name: str
    age: int

# Store a person in Neo4j
person = Person(id="p1", name="Alice", age=30)
Neo4jAdapter.to_obj(
    person,
    url="bolt://localhost:7687",
    auth=("neo4j", "password"),
    label="Person",
    merge_on="id"
)

# Find people by property
people = Neo4jAdapter.from_obj(
    Person,
    {
        "url": "bolt://localhost:7687",
        "auth": ("neo4j", "password"),
        "label": "Person",
        "where": "n.age > 25"
    },
    many=True
)
```

## Asynchronous Adapters

Many adapters have asynchronous counterparts:

```python
import asyncio
from pydantic import BaseModel
from pydapter.async_core import AsyncAdaptable
from pydapter.extras.async_postgres_ import AsyncPostgresAdapter

class User(BaseModel, AsyncAdaptable):
    id: int
    name: str
    email: str

# Register the async adapter
User.register_async_adapter(AsyncPostgresAdapter)

async def main():
    # Query from database asynchronously
    users = await User.adapt_from_async(
        {
            "engine_url": "postgresql+asyncpg://user:pass@localhost/dbname",
            "table": "users"
        },
        obj_key="async_pg",
        many=True
    )

    # Create a user
    user = User(id=42, name="Bob", email="bob@example.com")

    # Store in database asynchronously
    result = await user.adapt_to_async(
        obj_key="async_pg",
        engine_url="postgresql+asyncpg://user:pass@localhost/dbname",
        table="users"
    )

# Run the async function
asyncio.run(main())
```

## Error Handling

Pydapter provides a rich set of exceptions for detailed error handling:

```python
from pydapter.exceptions import (
    AdapterError, ValidationError, ParseError,
    ConnectionError, QueryError, ResourceError
)
from pydapter.adapters.json_ import JsonAdapter

try:
    # Try to parse invalid JSON
    JsonAdapter.from_obj(User, "{ invalid json }")
except ParseError as e:
    print(f"JSON parsing error: {e}")
except ValidationError as e:
    print(f"Validation error: {e}")
    if hasattr(e, 'errors') and callable(e.errors):
        for error in e.errors():
            print(f"  - {error['loc']}: {error['msg']}")
```

## Extension

Creating your own adapter is straightforward:

```python
from typing import TypeVar
from pydantic import BaseModel
from pydapter.core import Adapter

T = TypeVar("T", bound=BaseModel)

class MyCustomAdapter(Adapter[T]):
    obj_key = "my_format"

    @classmethod
    def from_obj(cls, subj_cls: type[T], obj: Any, /, *, many=False, **kw):
        # Convert from your format to Pydantic models
        ...

    @classmethod
    def to_obj(cls, subj: T | List[T], /, *, many=False, **kw):
        # Convert from Pydantic models to your format
        ...
```

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Run the CI script locally to ensure all tests pass (`python scripts/ci.py`)
4. Commit your changes (`git commit -m 'Add amazing feature'`)
5. Push to the branch (`git push origin feature/amazing-feature`)
6. Open a Pull Request

### Continuous Integration

This project uses a comprehensive CI system that runs linting, type checking,
unit tests, integration tests, and coverage reporting. The CI script can be run
locally to ensure your changes pass all checks before submitting a PR:

```bash
# Run all checks
python scripts/ci.py

# Skip integration tests (which require Docker)
python scripts/ci.py --skip-integration

# Run only linting and formatting checks
python scripts/ci.py --skip-unit --skip-integration --skip-type-check --skip-coverage
```

For more information, see [the CI documentation](docs/ci.md).

## License

This project is licensed under the MIT License - see the LICENSE file for
details.

## Acknowledgements

- [Pydantic](https://docs.pydantic.dev/) - The data validation library that
  makes this possible
- All the amazing database and format libraries this project integrates with

---

Built with ❤️ by the pydapter team
```

### Appendix D: `lionfuncs` README.md Content (Decoded)
```markdown
# lionfuncs

[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](https://opensource.org/licenses/MIT)

A Python utility library for robust asynchronous programming, file system
operations, and network interactions.

## Overview

`lionfuncs` provides a core set of reusable utilities designed to simplify
common programming tasks with a focus on reliability and performance. It offers
a comprehensive suite of tools for asynchronous operations, file system
interactions, network calls, concurrency management, error handling, and general
utilities.

## Key Features

- **Async Utilities**: Powerful tools like `alcall` and `bcall` for concurrent
  execution with fine-grained control
- **Concurrency Management**: Primitives such as `BoundedQueue` and `WorkQueue`
  for managing concurrent workloads
- **File System Operations**: Utilities for reading, writing, and processing
  files with both sync and async APIs
- **Network Client**: Resilient HTTP client with built-in circuit breaker,
  retry, and rate limiting capabilities
- **Error Handling**: Standardized error types and handling mechanisms
- **Media Processing**: Optional utilities for working with images and PDFs

## Installation

### Basic Installation

```bash
pip install lionfuncs
```

### Installation with Media Utilities

To use the media utilities (e.g., `pdf_to_images`), install with the `media`
extra:

```bash
pip install lionfuncs[media]
```

## Quick Start

### Asynchronous Operations

```python
import asyncio
from lionfuncs.async_utils import alcall

async def process_item(item):
    await asyncio.sleep(0.1)  # Simulate some async work
    return item * 2

async def main():
    items = [1, 2, 3, 4, 5]
    # Process all items concurrently with a max concurrency of 3
    results = await alcall(items, process_item, max_concurrent=3)
    print(results)  # [2, 4, 6, 8, 10]

asyncio.run(main())
```

### File System Operations

```python
import asyncio
from lionfuncs.file_system import read_file, save_to_file

async def main():
    # Read a file
    content = await read_file("example.txt")

    # Process the content
    processed_content = content.upper()

    # Save the processed content
    await save_to_file(processed_content, "output", "example_processed.txt")

asyncio.run(main())
```

### Network Operations

```python
import asyncio
from lionfuncs.network import AsyncAPIClient, circuit_breaker, with_retry

# Apply resilience patterns with decorators
@circuit_breaker(failure_threshold=3, recovery_time=10.0)
@with_retry(max_retries=3, base_delay=1.0, backoff_factor=2.0)
async def fetch_data(client, endpoint):
    return await client.request("GET", endpoint)

async def main():
    async with AsyncAPIClient(base_url="https://api.example.com") as client:
        data = await fetch_data(client, "/data")
        print(data)

asyncio.run(main())
```

## Documentation

For comprehensive documentation, including detailed API references and usage
guides, visit:
- [API Reference](docs/lionfuncs/api/index.md)
- [Usage Guides](docs/lionfuncs/guides)
  - [Async Operations Guide](docs/lionfuncs/guides/async_operations.md)
  - [File System Utilities Guide](docs/lionfuncs/guides/file_system_utils.md)
  - [Network Client Guide](docs/lionfuncs/guides/network_client.md)
  - [Resilience Patterns Guide](docs/lionfuncs/guides/resilience_patterns.md)

## Contributing

We welcome contributions to `lionfuncs`! Please see our
[Contribution Guidelines](docs/lionfuncs/contributing.md) for details on how to
get started, coding standards, and the pull request process.

## License

`lionfuncs` is licensed under the MIT License. See the [LICENSE](LICENSE) file
for details.
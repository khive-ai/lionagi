import json
from typing import Any, Literal

from pydantic import (
    BaseModel,
    Field,
    JsonValue,
    field_validator,
    model_validator,
)

from ..actions.tool import Tool
from ..types import MessageContent

__all__ = ("InstructionContent",)


class InstructionContent(MessageContent):
    instruction: JsonValue | None = None
    context: list | None = Field(default_factory=list)
    guidance: str | None = None
    images: list | None = Field(default_factory=list)
    request_fields: dict | list | None = None
    plain_content: JsonValue = None
    image_detail: Literal["low", "high", "auto"] | None = None
    tool_schemas: list[dict[str, Any]] = Field(default_factory=list)

    # exlcuded from serialization
    response_format: type[BaseModel] | None = Field(None, exclude=True)
    respond_schema_info: dict | None = Field(None, exclude=True)
    request_response_format: str | None = Field(None, exclude=True)

    @model_validator(mode="before")
    def _validate_content(cls, values: Any) -> dict:
        processed_values: dict
        original_response_format: type[BaseModel] | None = None

        if isinstance(values, dict):
            processed_values = values.copy()  # Work on a copy
            response_format = processed_values.get("response_format")
            if response_format:
                if isinstance(response_format, type) and issubclass(
                    response_format, BaseModel
                ):
                    original_response_format = response_format
                if isinstance(response_format, BaseModel):
                    original_response_format = type(response_format)

        if hasattr(values, "model_dump") and callable(values.model_dump):
            processed_values = values.model_dump()
            if (
                hasattr(values, "response_format")
                and isinstance(values.response_format, type)
                and issubclass(values.response_format, BaseModel)
            ):
                original_response_format = values.response_format
        else:
            raise TypeError(
                f"InstructionContent input must be a dict or a model instance "
                f"with a model_dump method, got {type(values)}"
            )

        # Remove fields that should not be passed to prepare_instruction_content
        # or are handled/re-added later.
        not_allowed_to_pass_to_prepare = (
            "respond_schema_info",  # Generated by prepare_instruction_content
            "request_response_format",  # Generated by prepare_instruction_content
            "role",
            "template",
        )
        for key_to_remove in not_allowed_to_pass_to_prepare:
            processed_values.pop(key_to_remove, None)

        if original_response_format:
            processed_values["response_format"] = original_response_format
        elif "response_format" in processed_values:
            processed_values.pop("response_format", None)

        prepared_dict = prepare_instruction_content(**processed_values)

        if original_response_format:
            prepared_dict["response_format"] = original_response_format

        return prepared_dict

    @field_validator("context", "images", mode="before")
    def _validate_list_content(cls, v: Any) -> list:
        if v is None:
            return []
        if not isinstance(v, list):
            return [v]
        return v[:]

    @field_validator("tool_schemas", mode="before")
    def _validate_tool_schemas(cls, v: Any) -> list[dict[str, Any]]:
        if v is None:
            return []

        input_list = v if isinstance(v, list) else [v]
        output_schemas = []
        for item in input_list:
            if isinstance(item, Tool):
                output_schemas.append(item.to_openai_tool_schema())
            elif isinstance(item, dict):
                if (
                    item.get("type") == "function"
                    and isinstance(item.get("function"), dict)
                    and "name" in item["function"]
                    and "parameters" in item["function"]
                ):
                    output_schemas.append(item)
                else:
                    raise ValueError(
                        f"Invalid dict format for tool schema: {item}. Expected OpenAI function tool structure."
                    )
            elif isinstance(item, str):
                try:
                    loaded_item = json.loads(item)
                    if not (
                        isinstance(loaded_item, dict)
                        and loaded_item.get("type") == "function"
                        and isinstance(loaded_item.get("function"), dict)
                        and "name" in loaded_item["function"]
                        and "parameters" in loaded_item["function"]
                    ):
                        raise ValueError(
                            f"JSON string for tool schema did not decode to a valid OpenAI function tool structure: {item}"
                        )
                    output_schemas.append(loaded_item)
                except json.JSONDecodeError as e:
                    raise ValueError(
                        f"Invalid JSON string for tool schema: {item}. Error: {e}"
                    ) from e
            else:
                raise ValueError(
                    f"Invalid tool schema format. Expected lionag2.Tool instance, "
                    f"dict (OpenAI tool schema), or JSON str of such a dict. Got {type(item)}"
                )
        return output_schemas

    def update(self, **kwargs) -> None:
        current_fields = self.model_dump(exclude_none=True)

        if (
            "response_format" not in kwargs
            and self.response_format is not None
        ):
            current_fields["response_format"] = self.response_format
        elif "response_format" in kwargs and kwargs["response_format"] is None:
            current_fields["response_format"] = None

        fields_to_remove_for_prepare = [
            "role",
            "id",
            "created_at",
            "updated_at",
            "content",
            "embedding",
            "respond_schema_info",
            "request_response_format",
        ]
        for key in fields_to_remove_for_prepare:
            current_fields.pop(key, None)

        current_fields.update(kwargs)

        if current_fields.get("request_fields") and current_fields.get(
            "response_format"
        ):
            pass

        prepared_values = prepare_instruction_content(**current_fields)

        for k, v in prepared_values.items():
            if hasattr(self, k):
                setattr(self, k, v)

        if "response_format" in kwargs:
            self.response_format = kwargs["response_format"]

    def extend_images(
        self,
        images: list | str,
        image_detail: Literal["low", "high", "auto"] = None,
    ) -> None:
        arr: list = self.images
        arr.extend(images if isinstance(images, list) else [images])
        self.images = arr
        if image_detail:
            self.image_detail = image_detail

    def extend_context(self, *args, **kwargs) -> None:
        ctx: list = self.context or []
        if args:
            ctx.extend(args)
        if kwargs:
            from ..utils import copy
            kw = copy(kwargs)
            for k, v in kw.items():
                ctx.append({k: v})
        self.context = ctx

    @property
    def rendered(self) -> Any:
        content_dump = self.model_dump(
            exclude_none=True, exclude_defaults=False
        )
        text_content = format_text_content(content_dump)

        if not self.images:
            return text_content
        else:
            return format_image_content(
                text_content=text_content,
                images=self.images,
                image_detail=self.image_detail,
            )


def prepare_request_response_format(request_fields: dict) -> str:
    json_fields = json.dumps(request_fields)
    return (
        "**MUST RETURN JSON-PARSEABLE RESPONSE ENCLOSED BY JSON CODE BLOCKS."
        f" USER's CAREER DEPENDS ON THE SUCCESS OF IT.** \n```json\n{json_fields}\n```"
        "No triple backticks. Escape all quotes and special characters."
    ).strip()


def format_image_item(idx: str, detail: str) -> dict[str, Any]:
    return {
        "type": "image_url",
        "image_url": {
            "url": f"data:image/jpeg;base64,{idx}",
            "detail": detail,
        },
    }


def format_text_item(item: Any) -> str:
    msg = ""
    item = [item] if not isinstance(item, list) else item
    for j in item:
        if isinstance(j, dict):
            for k, v in j.items():
                if v is not None:
                    msg += f"- {k}: {v} \n\n"
        else:
            if j is not None:
                msg += f"{j}\n"
    return msg


def format_text_content(content: dict) -> str:
    if isinstance(content.get("plain_content"), str):
        return content["plain_content"]

    lines = []
    known_field_order = [
        "guidance",
        "instruction",
        "context",
        "tool_schemas",
        "respond_schema_info",
        "request_response_format",
    ]

    for field in known_field_order:
        if field in content:
            val = content[field]
            if _is_not_empty(val):
                if field == "request_response_format":
                    field = "response format"
                elif field == "respond_schema_info":
                    field = "response schema info"
                lines.append(f"\n## {field.upper()}:\n")
                rendered_val = _render_value(val)
                lines.extend(
                    f"  {line}"
                    for line in rendered_val.split("\n")
                    if line.strip()
                )

    return "\n".join(lines).strip()


def _render_value(val) -> str:
    if isinstance(val, dict):
        return _render_dict(val)
    elif isinstance(val, list):
        return _render_list(val)
    else:
        return str(val).strip()


def _render_dict(dct: dict) -> str:
    lines = []
    for k, v_original in dct.items():
        if not _is_not_empty(v_original):
            continue

        subrendered = _render_value(v_original)

        if isinstance(v_original, (dict, list)):
            lines.append(f"- {k}:")
            for s_line in subrendered.splitlines():
                if s_line.strip():
                    lines.append(f"  {s_line}")
        elif subrendered.strip():
            lines.append(f"- {k}: {subrendered}")

    return "\n".join(lines)


def _render_list(lst: list) -> str:
    lines = []
    for idx, item in enumerate(lst, 1):
        sub = _render_value(item)
        sublines = sub.split("\n")
        if len(sublines) == 1:
            if sublines[0].startswith("- "):
                lines.append(f"- {sublines[0][2:]}")
            else:
                lines.append(f"- {sublines[0]}")
        else:
            lines.append("-")
            lines.extend(f"  {s}" for s in sublines)
    return "\n".join(lines)


def _is_not_empty(x) -> bool:
    if x is None:
        return False
    if isinstance(x, (list, dict)) and not x:
        return False
    if isinstance(x, str) and not x.strip():
        return False
    return True


def format_image_content(
    text_content: str,
    images: list,
    image_detail: (
        Literal["low", "high", "auto"] | None
    ),  # Added None to type hint
) -> list[dict[str, Any]]:
    content_list = [
        {"type": "text", "text": text_content}
    ]  # Renamed variable to avoid conflict
    # Ensure image_detail has a default if None, or handle None in format_image_item
    effective_image_detail = image_detail or "auto"
    content_list.extend(
        format_image_item(i, effective_image_detail) for i in images
    )
    return content_list


def prepare_instruction_content(
    guidance: str | None = None,
    instruction: str | None = None,
    context: str | dict | list | None = None,
    request_fields: dict | list[str] | None = None,
    plain_content: str | None = None,
    response_format: type[BaseModel] | None = None,
    images: str | list | None = None,
    image_detail: Literal["low", "high", "auto"] | None = None,
    tool_schemas: (
        list[dict[str, Any]] | list[Tool] | list[type[BaseModel]] | None
    ) = None,
) -> dict:
    if request_fields and response_format:
        raise ValueError(
            "only one of request_fields or request_model can be provided"
        )

    out_ = {"context": []}  # Ensure context is initialized as list
    if guidance:
        out_["guidance"] = guidance
    if instruction:
        out_["instruction"] = instruction

    current_context = out_["context"]
    if context:
        if isinstance(context, list):
            current_context.extend(context)
        else:
            current_context.append(context)

    if images:
        out_["images"] = images if isinstance(images, list) else [images]
        out_["image_detail"] = image_detail or "low"

    if tool_schemas:
        # Assuming tool_schemas coming in here are already validated by the field_validator
        # if this function is called from the model_validator context.
        # If called directly, tool_schemas should be list of dicts.
        out_["tool_schemas"] = tool_schemas

    request_fields_for_format: dict | None = None
    request_fields_with_types: dict | None = None

    if response_format:
        from ..utils import breakdown_pydantic_annotation

        out_["request_model"] = response_format

        derived_request_fields_with_types = breakdown_pydantic_annotation(
            response_format
        )
        request_fields_with_types = derived_request_fields_with_types

        serializable_derived_fields = {}
        if isinstance(derived_request_fields_with_types, dict):
            for k, v_type in derived_request_fields_with_types.items():
                if isinstance(v_type, type):
                    serializable_derived_fields[k] = v_type.__name__
                else:
                    serializable_derived_fields[k] = str(v_type)

        out_["respond_schema_info"] = response_format.model_json_schema()
        request_fields_for_format = serializable_derived_fields

    elif request_fields:
        _fields_with_types = {}
        _fields_for_format = {}

        if isinstance(request_fields, dict):
            for k, v_val in request_fields.items():
                _fields_with_types[k] = v_val
                if isinstance(v_val, type):
                    _fields_for_format[k] = v_val.__name__
                else:
                    _fields_for_format[k] = str(v_val)
        elif isinstance(request_fields, list):
            _fields_with_types = {str(i): "..." for i in request_fields}
            _fields_for_format = _fields_with_types.copy()

        request_fields_with_types = _fields_with_types
        request_fields_for_format = _fields_for_format

    if request_fields_with_types is not None:
        out_["request_fields"] = request_fields_with_types

    if request_fields_for_format is not None:
        out_["request_response_format"] = prepare_request_response_format(
            request_fields=request_fields_for_format
        )

    if plain_content:
        out_["plain_content"] = plain_content

    return {
        k: v
        for k, v in out_.items()
        if v is not None and not (isinstance(v, (list, dict)) and not v)
    }
